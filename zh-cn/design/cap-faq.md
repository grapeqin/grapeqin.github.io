# CAP FAQ

对于分布式系统工程师来说，CAP定理是个经常被引用、经常被误解的富有争议的主题。 本FAQ的目标是解释CAP的知识，以帮助那些刚接触该定理的人快速上手，并解答常见的误解或分歧点。

## 1.CAP定理来自于哪里？

Eric Brewer博士在2000年的分布式计算原理会议上做了题为“[走向稳健的分布式系统](http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf)”的主题演讲。在这次演讲中，他提出在当时还未得到证实的“CAP定理”，说明在分布式系统中正确性和可用性之间存在矛盾。
两年后，麻省理工学院分布式系统研究人员赛斯·吉尔伯特和南希·林奇教授在他们的论文[《布鲁尔猜想和一致的、可用的、可分区的web服务的可行性》](https://users.ece.cmu.edu/~adrian/731-sp04/readings/GL-cap.pdf)中正式证实了这一猜想。

## 2.CAP定理到底在说什么？

CAP定理(以下简称“CAP”)指出，在异步网络中构建一个同时满足以下三个属性的读写存储实现是不可能的:

- 可用性 -- 向数据存储发出的请求最终是否总会完成？
- 一致性 -- 所有节点上的读写操作都是原子性的或线性一致的吗?
- 分区容忍性 -- 网络总是允许丢弃一些消息

CAP定理告诉我们，我们不可能建立一个读写存储，既能响应每个请求，又能返回预期的结果。这是个不可能的结果——它告诉我们，我们可能想做的事情实际上是无法达成的。它已经适用于许多在过去几年里已经建立和正在建立的分布式系统，它并不意味着我们不能在这些限制条件下构建有用的系统。
然而，细节决定成败。在你叫喊“是的，但是……怎么样”之前，请确保你理解了以下关于CAP定理允许和不允许的内容。

## 3.什么是"读写存储"？

CAP定理与寄存器的理论结构比较相似。寄存器是包含如下两种操作的一种数据结构：

- `set(X)` 将寄存器的值设置为X
- `get()` 返回寄存器中设置的最后一个值

键值对的存储可以建模为一个寄存器的集合。尽管寄存器看起来非常简单，但它抓住了许多分布式系统想要做的事情的本质——写入数据并将其读取回来。

## 4.原子(或线性)是什么意思？

原子(或线性)一致性保证了当客户端执行`get()`操作时可以返回什么值。其思想是，在所有客户端看来，寄存器似乎只运行在一台机器上，并按照请求到达的顺序响应。

还有一种情况就是由所有客户端同时发起的操作集合，我们称作并发。在原子一致性的前提下，这些操作的结果必须与这些操作串行(按顺序，一个接一个)执行保持一致。

这也称为强一致性。另外还有一种称为`最终一致性`的保证，它允许在写操作可见之前存在一定的延迟。看下面的示例：

```shell
set(10), set(5), get() = 10
```

这种执行结果在原子一致性的保证下是非法的。

原子一致性能让读取寄存器值的客户端之间感知对方的更新操作。比如，我先读取了`X`，然后告诉你，你也访问寄存器并读取`X`的值。在弱一致性的保证下，两次读取的值可能不一样。
在下面的例子中，我通过客户端`A`执行写入操作，意味着客户端A执行如下的操作。

```shell
B:set(5), A:set(10), A:get() = 10, B:get() = 10
```
这是原子性的执行。但下面的则不是：

```shell
B:set(5), A:set(10), A:get() = 10, B:get() = 5
```
因为它等同于下面的执行序列

```shell
B:set(5), B:get() = 5, A:set(10), A:get() = 10
```

在第二个例子中，如果A在执行`get()`之后告诉B寄存器(10)的值，B将错误地认为某个第三方在`A:get()`和`B:get()`之间写入了5。
如果A、B之间不能互相感知，则B不会知道`A:set()`这个操作，它只能看到寄存器的一致性视图，看起来就好像是`B.get()`操作发生在`A.set()`之前。

[维基百科](https://en.wikipedia.org/wiki/Linearizability) 这里有更多详细的信息。莫里斯·赫利希1990年的论文原文可以在[这里](http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf)找到

## 5. 异步是什么意思？

在异步网络中，通过网络传递或机器处理的消息所需时间是没有界限的。这个特性导致的结果就是让我们无法区分到底是机器处理失败了，还是消息传递延迟了。

## 6. 可用性是什么意思？

我们说一个数据存储可用，当且仅当所有`get`和`set`请求最终都能返回其规范定义的响应时才成立。它不允许返回错误的响应，因为一个系统可以通过总是返回错误消息来让它保持可用。
对于响应没有固定的时间限制，系统可以按照它需要的时间来处理请求。但系统最终必须做出响应。请注意这里有一强一弱的需求。强需求是指请求必须100%的要有响应(没有可用程度一说)，弱需求是指响应时间没有设限(必须是一个有限的时间)。

## 7. 分区是什么？

分区是指网络丢弃消息使得无法将消息投递给一个或多个系统节点(注意不是延迟消息--最终能投递不是分区)。这个术语有时用来指在两个集群之间没有消息传递的一段时间。这是一种更加严格的失败模型，我们把所有这些分区称作总分区。

CAP定理的证明依赖于这个总分区。在实践中，消息会流经一个组件，如果出现网络分区那么在总分区里面的节点之间就会丢失消息。

## 8. 为什么CAP是正确的？

其基本思想是，如果客户端向分区的一侧写入数据，那么任何到该分区另一侧的读操作都不可能知道最近的写入操作。现在面临一个选择:是用可能过时的信息响应读取，还是等待(可能永远等待)从分区的另一端收到更新消息并牺牲可用性?
这是一种构造证明--我们演示了一个系统不能同时保持一致性和可用性的单一场景。CAP定理受到关注的另一个原因是它设想的这种场景在现实中是存在的。一旦网络设备故障，必然会出现网络分区现象。

## 9. 系统什么时候必须放弃一致性或可用性？

一致性和可用性是强保证的:必须100%的请求都满足条件，只要有一个不一致的读或不可用的写，就会破坏一致性或可用性的保证。在满足这个临界条件之前，系统都能同时保持一致性和可用性，这并不会违反任何已知的规则。

对于长期运行的分布式系统来说，在它的生命周期内会遇到数百万的请求，CAP定理告诉我们，现实中总是会遇到这些临界条件，因此要慎重的考虑当系统失败时我们如何权衡一致性与可用性。

## 10. 为什么把系统描述为`CA`有些人会生气？

Brewer的报告，Gilbert的论文，以及其他一些文献，都会建议把`C`、`A`和`P`在实现上放在同等重要的位置，并且会说，请随意选择其中的两个吧。然而，这通常被认为是一种误导，因为你不能选择"分区容忍度":你的系统可能经历分区，也可能不会。

CAP可以更好地理解为在构建可能受分区影响的系统时必须做出的权衡。在真实的分布式系统中，没有100%可靠的网络。因此不存在现实意义上的CA系统。在分布式系统中，你总是会遇到网络分区问题，因此你必须在某个时刻折中选择C或A。

因此我们可以用下面的描述重新定义该定理：

如果你的系统可能会面临网络分区问题，它就不可能总是满足一致性和可用性。

有一些系统是永远不会面临网络分区的 -- 比如单站点数据库。这些系统通常与CAP最实用的场景不相关。如果你把一个系统描述为`CA`系统，可能是你对某些概念的理解有误。

## 11. 如果消息没有丢失呢？

Gilbert论文一个令人惊讶的结果是，在异步网络中原子寄存器不能保证可以任何时候都可用，并且只在没有消息丢失时才能保证系统的一致性。
这个结果主要取决于网络分区的特性，它主要想表达的是，我们没有办法在一条消息被丢弃或一个节点不能无限等待响应的情况下仍然要维持整个系统的可用性，如果它提前响应那么系统返回的数据可能是不一致的。

## 12. 我们的网络真的是异步的吗？

当然是的。不同的网络有不同的特点。比如下面的场景

- 如果你的节点没有时钟(不太可能)或者它们的时钟不同步(更有可能)
- 系统进程可能任意延迟消息的传递(重试、GC停顿等)

这些情况中网络都可以被认为是异步的。

Gilbert和Lynch还证明，在半同步系统中，节点共享存储但时钟不同步，即使每条消息的处理时间有上限，仍然不可能实现可用的原子存储。

第8个问题的结论在半同步系统中并不成立，因为实现一个总是可用的原子存储是有可能的，当所有的消息都正确投递后系统的一致性也得以实现。

## 13. FLP和CAP之间的关系是什么？

## 14. 

## 15. 失败的机器与分区的机器相同吗？

不同。失败的机器通常会被摘除以防止它向客户端请求响应。
当网络集群中有N-1个节点都失败了，很容易的证明它不可能实现一个原子存储。这个结论涉及到写入多少节点(性能考量)和容错度(可靠性考量)之间的权衡。

## 16. 慢速的机器和分区的机器一样吗？

不同。消息最终会投递给一台慢机器，但怎么也不会投递给一台已分区的机器。然而，速度较慢的机器在区分丢失的消息(或故障的机器)和速度较慢的机器方面起着重要作用。这个困难正是CAP、FLP和其他结果成立的核心所在。

## 17. 我是否“绕过”或“击败”了CAP定理

不能。你可能已经设计了一个不受CAP定理严重影响的系统。这就够了。

